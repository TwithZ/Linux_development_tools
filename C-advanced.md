# C语言深度解析

-------------------

## 1.零碎知识

- C程序的内存结构也叫**存储映射**。

- static修饰局部变量，改变的是它的存储位置，从栈变到了全局区，生存期也变成了整个程序结束。

- static修饰全局变量，改变的是它的作用域，仅在本文件可见，而不改变它的存储位置，因为它本来就在全局区。

- static修饰函数，改变的也是它的作用域，仅在本文件可见，变成了私有函数。

- 看到static的语法并没有固定的套路，这是C语法设计上的小缺陷。

- 从前的C标准里面有一种变量叫 **寄存器变量**, 其实它意思就是建议编译器把这个变量放到CPU的通用寄存器里.

- 全局符号，本地符号。

- 我没有把它加入环境变量，我就不能在任意目录下去调用它。

- 可以把程序分为3层, 第一层是你自己写的, 第二层是你调用的库, 第三层是内核提供的.

- IDE集程序编辑器, **工程管理器**, 编译器, 汇编器, 链接器, 调试器, 二进制工具, **库**, **头文件**于一身, 留给用户的使用接口就是创建一个工程, 编写代码, 运行代码. 这种**一站式**开发方式, 大大简化了软件的开发!

- 什么叫**硬编码**? 其实就是**生硬的编码**! 就是把代码中那些路径啥的, 都写成字符串常量的形式, 也就是直接写死了, 而不是说用一个字符串变量去存放那个路径. 这样的代码灵活性就差一些.

- 以前只知道汇编的不支持跨平台, 其实C/C++这种语言的跨平台能力也是相对比较弱的!

- 

---------------------------------------



## 2.编译过程与gcc

- 两种开发方式：IDE开发方式、编辑，编译分开开发方式。（编辑，编译分开开发方式是**本源开发方式**）

- 编译过程：

  - 编译分为：<u>预处理、编译、汇编、链接。</u>其中的“编译”特指中间的某个过程，这4个过程合在一起，我们也统称为编译，所以“编译”二字到底指的是第二个过程，还是全部过程的统称，这个就要看语境了。
  - ![image-20220615171556136](C:\Users\屠文博\AppData\Roaming\Typora\typora-user-images\image-20220615171556136.png)
  - 在链接之前的步骤全部都是对**单个文件**进行的处理，不涉及文件之间的交互。

  1. **预处理**：<u>宏替换、包含头文件、条件编译、处理一些特殊的预处理命令。</u>所以这个 .i 文件其实你打开之后还是跟.c文件差不多的，还是能看懂的。
  2. **编译**：利用 c 的语法将 c 源码翻译为汇编源码。这个 .s 文件打开之后其实也看得懂。
  3. **汇编**：使用汇编器将汇编文件翻译成纯二进制文件，也就是机器指令，所以这个 .o 文件打开之后就看不懂了。但因为这是单个文件的机器指令，它是不完整的，而且它也没有启动代码，所以它不能直接单独运行，只有在链接之后才行。
  4. **链接**：
     1. 将众多的 .o 文件合成一个完整的可执行文件，因为 .o 之间有**相互依赖关系**。
     2. 链接时加入额外的**启动代码**。这个启动代码并不是我们自己写的，main函数是由启动代码调用的，我们的程序是从启动代码开始运行的。
     3. 链接为一个可执行文件时，需要进行**符号解析**和**地址重定位**。

  - 就算你一个工程就一个 .c 文件，想要运行也必须要链接才行，因为只有经过链接，才有 启动代码 和 重定位后的地址，否则你是无法运行的。
  - 一般我只使用一个 gcc 直接**一次性完成**上面4个过程，因为它内部会自动调用 预处理器、编译器、汇编器、链接器 这些，而且这样它还会自动把产生的那些中间文件给删除了，只剩下我们需要的可执行文件，贼方便。
  - gcc 就是一个总的**调度程序**，你给它不同的选项，它就能进行你指定的过程。这样只用一个 gcc 就很方便了。
  - gcc选项：

  - ```c
    //! gcc在使用的时候一个原则就是：-o选项后面跟 目标文件，其它选项之后跟 源文件，
    //! 只要遵循这个原则，命令中源文件和目标文件的顺序都无所谓.
    
    //! 1. -E 将源文件预处理得到 .i 文件. 
    //! 如果没有写目标文件名，则直接把预处理的结果全部输出到控制台.
    gcc -E hello.c -o hello.i
        
    //! 2. -S 将 .i 文件编译得到 .s 文件. 但也可以直接从 .c 到 .s ，它内部会自动先进行预处理.
    //! 如果不写目标文件，则自动保存为同名的 .s 文件.
    gcc -S hello.i -o hello.s
    gcc -S hello.c -o hello.s
        
    //! 3. -C 将 .s 汇编得到 .o 文件，但也可以直接从 .c 或 .i 得到 .o ，它内部会自动进行.
    //! 如果不写目标文件名，则自动保存为同名的 .o 文件.
    gcc -C hello.s -o hello.o
    gcc -C hello.i -o hello.o
    gcc -C hello.c -o hello.o
        
    //! 4. 想直接得到可执行文件的话，不用跟其它额外选项.
    gcc hello.c -o hello.exe
    gcc hello.i -o hello.exe
    gcc hello.s -o hello.exe
    gcc hello.o -o hello.exe
        
        
    //! 注意注意! 上面的编译选项的大写和小写代表的意思是不一样的!!!    
    
    //! 5. -g 选项可以在生成的 .exe 文件中加入调试信息，这样就可以用 gdb 调试了.
    //! 但是你的可执行文件包含调试信息的话，体积会变大很多很多，所以调试完成后，发布时应该去掉调试信息.
    gcc -g hello.c -o hello.exe
        
    //! 6. o0/o1/o2/os/o3 选项可以用来指定优化级别. o0 < o1 < o2 < os < o3
    //! 如果不指定优化级别，默认 o1 级别.
    //! 使用优化可以减小可执行文件的大小, 也可以加快执行速度.
    gcc -o2 hello.c -o hello.exe
        
    //! 7. -std 选项可以指定编译时使用的语言标准.
    //! 不指定的话就使用默认标准.
    gcc -std=c11 hello.c -o hello.exe
        
    //! 8. -v 选项可以显示编译过程的详细信息.
    gcc -v hello.c -o hello.exe  //!< 显示预处理、编译、汇编、链接所有过程的详细信息.
    gcc -v -E hello.c -o hello.i //!< 单个过程的话，就只显示单个过程的详细信息.
        
    //! 9. -Wall 选项可以列出所有警告信息，严重的还是不严重的都给报出来.
    gcc -Wall hello.c -o hello.exe
        
    //! 使用 ./demo 就可以运行demo程序.
    //! Linux中不使用后缀名来区分文件, 所以你编译完成的可执行文件, 你可以起任意的名字.
    gcc demo.c //!< 直接这样也行, 这样生成的可执行文件默认为 demo.out
    gcc demo.c -o xxxxx //!< 这样你也可以自己自定义文件名, 而且文件名你可以任意定, 想定啥定啥, 要想确定一个文件是不是可执行文件, 就通过 ls -l 命令, 看它有没有 可执行权限就行了.
    
    //! 当进行多文件编程的时候, 你要编译的时候, 需要把全部的.c文件都指定上去, 如果你包含头文件的时候不是指定的绝对路径, 那你还要在编译的时候用-I选项指定搜索路径.
    gcc main.c a.c b.c -Iinc -o main
        
    file main //!< 可以查看到可执行文件main的信息, 包括位数啊, 运行的机器的机构啊等等信息.
    ```

- ![image-20220727133136462](C:\Users\屠文博\AppData\Roaming\Typora\typora-user-images\image-20220727133136462.png)

- ![image-20220727133214601](C:\Users\屠文博\AppData\Roaming\Typora\typora-user-images\image-20220727133214601.png)

- 如果你在源文件中包含头文件时, **指定了绝对路径**, 那你在编译的时候就不用再用`-I`选项指定**头文件搜索路径**了. *玩MDK的时候也要让指定头文件搜索路径, 它肯定也是要把那些路径在编译的时候都用-I选项指定上, 那我要是在包含头文件的时候都把路径也写上那应该就不用再添加头文件包含路径了.*

- GCC指的是编译器集合，gcc指的是集合中的gcc程序。

- 交叉编译是在一个平台上生成另一个平台上可执行的代码. 其实你用MDK编译就是交叉编译啊, 因为你在Windows上编译程序, 但是在单片机里运行程序. 为什么要进行交叉编译? 1.平台上不允许或不能安装我们所需要的编译器. 比如C51就没法安装环境. 2.目标平台还没有建立, 连操作系统都没有, 而操作系统也需要编译.

- 编译器嘛, 其实说到底它也就是一个用C开发的程序而已.

- GNU开发的gcc可以面对很多的环境, 比如x86-Windows环境, x86-Linux环境, ARM-Linux环境.

- 如果你要你的程序能够跨平台的话, 通常都是需要通过判断标识特定平台的宏, 来进行条件编译, 进而实现只编译适合特定平台的代码.

- 一般你的大型项目都是需要一个**配置文件**的.

- 用 `“”` 包起来的头文件意思就是: 到**程序员自己指定的路径**下去搜索头文件. 这种一般都是用户自己写的头文件. 如果在程序员指定的路径下找不到指定的头文件的话, 就再到系统指定的路径下去找, 再找不到的话就报错. (也就是说那个字符串就是一个**路径**)

- 用 `<>` 包起来的头文件意思就是: 到**系统指定的路径**下去搜索头文件. 因为系统包含的头文件都是在固定位置的. 如果在系统指定的路径中找不到头文件的话就报错了.

- 

- 编译到最后, 会有**crt1.o, crti.o, crtbegin.o**这几个程序来生成**启动代码**, 这3个 .o 是由GCC编译器集合提供的, crt就是C/C++ run time的意思, 就是**运行时环境**. 启动代码的作用就是搭建C/C++的运行环境. **_start**是整个程序的入口, 而后调用main函数.

- 还有crtend.o, crtn.o用于生成**扫尾代码**, 程序运行结束时, 需要做一些扫尾工作, 这两个.o也是gcc开发者编写的. 为了方便描述, 我们往往将扫尾代码认为是启动代码的一部分.

- 所以我们一般说生成启动代码的程序包括5个: crt1.0, crti.o, crtbegin.o, crtend.o, crtn.o

- 裸机时返回时的意义不大, 如果基于OS运行, 则将返回值交给OS.

- 启动代码的作用: 其核心作用就是, 在内存中建立C程序运行所需的“堆和栈”, 堆和栈其实就是程序运行时所需的运行环境之一, 所谓运行环境, 就是程序运行时必须要有的支撑.

- <u>害所谓的启动代码, 在单片机上的体现就是那个启动文件嘛! 一般的C程序的启动代码跟单片机上的其实做的事都是一样的. 因为单片机开发的特殊性, 它往往是裸机程序, 而且又是后还可能会修改启动文件, 所以提供给了用户启动文件. 而那些带OS的一般就不提供启动代码了, 而是直接给你一个 .o 文件, 你到最后链接上它就可以了.</u>

- 

-----------------------------------



## 3.静态链接与动态链接

- 链接是必须的, 因为你写的代码里面包含的一些标准的头文件, 你程序里面又调用`printf`啥的, 而头文件又只是声明, 只有链接到标准库才能使用标准库里的函数啊.
- 简单说:
  - 静态链接: 编译时完成链接.
  - 动态链接: 程序运行起来后, 根据需求再去链接.
- 链接的时候主要是链接**函数**和**全局变量**.

### 3.1静态链接

- 静态链接就是在编译的时候, 调用GCC里面包含的 ld/collect2 链接程序, 将所有的 .o 中的机器指令整合到一起, 然后保存为可执行文件.
- 什么时候用到静态链接: 编译时用到, 编译时的链接就是静态链接, 所以链接程序 ld/collect2 也可以称为**静态链接器**.
- 静态链接就做了两件事: 符号解析 和 重定位, 下面详细介绍:

#### 3.1.1符号解析

- 符号解析的目的就是将 *符号的引用* 和 *符号的定义* 联系起来. 意思就是比如我在一个文件里面使用了一个符号, 调用了另一个文件里面的函数, 那得让做个标记啊, 得以后运行的时候要让机器知道我调用的是那个函数啊, 它的实现代码在哪里啊, 所以也就是 我调用的地方 跟 具体实现它的地方, 二者之间建立一个联系. (也就是我进到你的文件里面, 哎我看看你这调用是调用的啥, 它的定义在哪, 我对应一下)
- 为了方便实现符号解析, 编译得到 .o 文件时, 每个 .o 文件都会包含一张**符号表**. 符号表里记录了以下两个内容:
  - 记录本文件中 定义 了些什么符号.
  - 记录本文件中 引用 了些什么符号.
- 

#### 3.1.2重定位

- 重定位就是将 .o 文件中的每个机器指令的**逻辑地址**, 重定位为(转化为)**实际运行时的地址**.
  - 如果是裸机运行的, 那实际运行时的地址就是内存的物理地址.
  - 如果是基于OS运行的, 那实际运行地址就是虚拟内存的地址.
- 为啥需要这样呢? 因为逻辑地址只是理论上的, 这个地址是无法被CPU取值运行的, 因为逻辑地址既不是实际的物理地址, 也不是虚拟内存的虚拟地址, 它只是在编译时临时给的一个编号.
- 

### 3.2动态链接

- 动态链接就是在编译的时候只留下调用接口, 当程序真正运行的时候, 才去链接执行. 动态链接这件事不是在编译时发生的, 是在程序动态运行时发生的.
- 什么时候用到动态链接呢? 使用**动态库**的时候, 动态库就是动态链接的. 比如`printf`函数, 这个函数基本都是动态库提供的, 程序编译后代码里面是没有`printf`函数的代码的, 只有`printf`这个接口, 当程序运行起来后, 再去动态链接`printf`所在的动态库, 那么程序就能调用`printf`函数了.
- 如何理解这里的接口? 如果以C源码的角度来看, 这里的接口就是`printf`函数名. 但是程序被编译为二进制文件后, `printf`就变成了一个地址, 所以在二进制代码的角度, 这里的接口就是*函数第一条指令的地址*.
- 动态链接由动态链接器来实现, 这也是GCC里面提供了的.
- 

------------------------------------------



## 4.静态库与动态库

- 如何得到库? 
  1. 先写好一堆的 .c 文件, 里面提供了各种工具函数.
  2. 将这些 .c 分别编译为对应的 .o
  3. 将所有的这些 .o 打包为一个库文件(静态库/动态库).
     - 静态库: 按照静态库的方式打包.
     - 动态库: 按照动态库的方式打包.
- 只是因为**打包规则**不同, 而得到不同的库.
- <u>链接静态库与链接一般的 .o 没有区别.</u> 比如如果printf函数是由静态库提供的话, 那就需要链接printf所在的静态库.
- 静态库是 .o 的集合, printf在其中的某个 .o 中, 链接静态库时, 使用printf这个符号去搜索静态库中所有的 .o , 如果找到了**printf所在的 .o** 则将其链接到自己的程序中.
- 其实自己创建静态库和动态库也很简单, 就一条命令就可以了.
- *反正不管是静态库还是动态库, 在你编译链接的时候都要在命令中指定一下. 只不过如果你指定的是静态库, 它就直接给你链接进去了. 而如果你指定的是动态库, 那只是给你做个标记, 在运行的时候才链接. 而你单纯看它生成的文件其实是没啥区别, 但是你用 ls -lh 命令查看就会发现, 其实动态链接的文件是要比静态链接的文件小的.*
- **静态库的缺点:** 链接静态库的时候, 其实就是将库中的一个或几个 .o 包含到自己的程序中, 每个程序链接静态库后, 都会包含一份独立的代码. 也就是你写了好几个程序, 但你每个程序编译完之后, 里面都包含一份库里的 .o , 那这些重复的代码就都需要占用独立的代码空间, 而程序运行的时候是需要把代码加载到内存的, 所以这样一来就很浪费内存空间啊, 当你的库很大的时候那更是如此啊! 这也是静态链接库的主要缺点. 所以也就出现了动态库.
- 动态库主要是为了解决静态库的缺点而存在的.
- 在链接动态库的时候, ld/collect2并不会将动态库中的一个或几个 .o 代码直接链接(复制)到自己的程序中, 只会留下调用接口. 程序在运行时再去将动态库加载到内存中, 然后就能调用动态库中的函数了.
- **动态库的优点:** 不管多少个程序使用了这个动态库, 这些程序只会共享使用同一份动态库, 因此动态库也被称为**共享库**.
- 动态库的代码是被全部加载到内存中的吗? 是的, 因为动态库并不知道你的程序需要使用哪个函数, 所以整个动态库都会被加载进内存.
- 动态库也就是你编译的时候通过选项指定一下动态库, 然后当程序运行起来的时候, 发现你要链接一个动态库, 首先检查一下内存中有没有这个动态库, 如果没有, 那就去硬盘里找, 找到之后就将动态库的所有代码都加载到内存中, 并得到整个动态库在内存中的起始地址. 而如果前面已经有程序加载过的话, 那就不需要再加载了, 直接在内存中获得动态库的起始地址就可以了.
- 其实你调用库中的函数跟调用普通的函数一样, 都只是跳转一下地址而已.
- 静态库的后缀:
  - Windows: .lib
  - Linux: .a
- 动态库的后缀:
  - Windows: .dll
  - Linux: .so



P13

-------------------------



## 宏

- 定义有参数的宏时, 建议所有层次都加上括号.
- 因为有参的宏它不需要写参数类型, 又可以在内部使用typeof, 所以可以实现类似函数模板的功能. 实在不行我可以要求用户传一个专门用来标识类型的参数. 有时候宏要比函数更加灵活!
- 为了防止无限制递归展开, 当宏调用自身的时候, 不再继续展开.
- 

---------------



## Powershell

简单点说 Powershell 是 cmd 的超集，也就是，cmd 能做的事情，Powershell 都能做，而且 Powershell 还能额外做许多 cmd 做不了的事。

二者都可以做命令行交互。

Powershell 是专为系统管理员设计的新的 Windows 命令行 shell。

- 对于程序的警告来说，虽然不是“编译链接”的严重错误，但是在程序的运行过程中，这些警告可能会演变为威胁程序正常运行的错误，所以警告是程序的隐患，因此在实际开发中，编译时必须将警告排除。
- 

-----------------



## 转义字符

- 为什么要有转义字符？字符嘛，就是用单引号括起来的东西，但是字符有的是可见的，也就是可以打印输出出来的，就像 ‘a’ , ‘b’ 这些，但是有些字符是没办法打印的，但是这些字符一般又是在打印的时候所必须的，这里叫它们 字符 是为了统一，实际上这些字符是为了**实现一些功能**，比如 换行，回车，退格，换页 啥的，对于这些符号嘞，肯定不能用普通的字符去表示啊，因为其它的字符都被编码过了啊， 这就发明了转义字符，所谓“转义”也就是转换意义，就是这个字符不再是原来的意思，机器需要把它转换成其它的意义。那你就可以把 \ 看作是用来转义的，对谁进行转义呢？就是它后面跟的那个字符，比如 ‘\n’ ，本来人家 n 好好的就是一个字符 n 的意思，现在转成 换行 的意思了。其实转义字符里面的那个 \ 也可以理解为是转义字符这种特殊字符它们的**前缀**，后者说是一个**标记**，<u>告诉编译器处理的时候，看到这个前缀，就要**根据它后面的那个字符**转换一下它的意义。</u>
- 斜杠 /，反斜杠 \ 。怎么记？就记住斜杠的话，写“斜”字的时候第一笔就是 / 。

------------------------



## 结构体定义在.c文件

- 将 struct 的定义放到 .c 文件中的意图：
  1. 我只希望这个 struct 在这一个 .c 文件中可见，不想暴露给其它文件，只作为一个私有的，作为一个辅助，这时放在 .c 里要比放在 .h 文件中更好一些。
  2. 放在 .h 中会使这个 struct 的影响变大，如果后期有修改的话，所有依赖的文件都需要重新编译，会影响编译效率。

------------------------------------



## 命令行参数

- 执行程序时, 可以从命令行传值给C程序, 这些参数被称为命令行参数. 它们对程序很重要, 特别是需要从外部控制程序的时候.
- 命令行参数是由`main()`函数来处理的, 其中`argc`是指传入的参数的个数, `argv[]`是一个指针数组, 指向传递给程序的每个参数.
- 应当指出的是, `argv[0]`**始终存储可执行程序的名称**, `argv[1]`指向第一个命令行参数. 如果在命令行中没有提供任何参数, `argc`将为1, 否则, 如果传递了一个参数, `argc`将被设置为2.
- 或者你也可以这样理解, 比如你在命令行中这样写: `./hello twb loujie`, 你就把`./hello`当作第0个参数, `twb`当作第1个参数, `loujie`当作第2个参数.
- `main()`函数的两个参数只是约定俗成写成`int argc, char* argv[]`, 事实上你也可以随便起名.
- `argc`即argument count, `argv`即argument value.
- 多个命令行参数之间用空格分隔即可.
- 但是如果参数本身带有空格, 那么传递参数的时候要使用双引号或单引号括起来.
- 看到`main()`的第二个参数是`char* argv[]`, 即数组里面的指针都是**指向字符串的指针**, 那也就是说这里的*命令行一般只用于传字符串类型的命令行参数, 而不是用来传整数的.*

-------------------------------



### 字符串

- 知道定义字符串有2种方法:
  1. 使用指针: `char* str1 = “hello world”;`
  2. 使用数组: `char str2[20] = “hello world”;`
- 这两个到底有什么区别呢? 其实认准一点就可以了: 就是那个字符串常量`“hello world”`始终都在, 它被**存储在.data段里的只读数据区**, 编译的时候就放到那里了. 第一种方法是直接在**栈里定义了一个指针变量**, 让它指向了只读数据区里的那个字符串; 而第二种方法是在栈里又开辟了一块20个byte的内存, 用来存字符串, 它其实是**把常量区的字符串给copy了一份到栈里面**.
- 只要是出现了字符串常量, 编译器都会在它的末尾放上一个`‘\0’`用来标记字符串的结尾. 所以在只读数据区里, 就有一个`“hello world\0”`安安稳稳的躺在那儿. 也就是说你写一个字符串常量的时候, 它的末尾就**始终隐含着**一个`‘\0’`. 所以你用数组存放的时候, 由于你那相当于对数组进行初始化啊, 所以数组里自然而然的也就应该有一个`‘\0’`.
- 

------------------------------------



### 常量折叠

- 当C程序中存在常量表达式时, 编译器在编译的时候会把常量表达式优化成一个固定的常量值, 以节省存储空间. 我们把这种编译优化称为常量折叠.

- ```c
  int val = 2 * 3 + 4 * 5;
  //! 这样的会直接把表达式 2 * 3 + 4 * 5 优化成一个常量26.
  ```

--------------------------



## 指针专题

- 从**汇编语言**的角度来看, 在汇编语言中是没有数据类型的概念的, 当我们使用DCB, DCD伪指令去为一个数据对象分配存储空间时, 要考虑的主要是**存储地址**, **存储大小**和**存储内容**这3个基本要素, 它和高级语言中的**变量名**, **变量类型**和**变量值**是一一对应的.
- 变量名的本质, 其实就是一段内存空间的别名. 变量名就是一个符号, 它被编译器绑定到一块内存. 而符号被保存在符号表里.
- 我们可以通过变量名来对与它绑定的内存空间进行读写, 额不是直接使用内存地址. 这种通过变量名访问内存的方式, 既方便了程序的编写, 也大大增强了程序的可读性.
- 指针变量就是一种普通的变量, 只不过专门用来存放变量在内存中的**起始地址**. 指针变量也是变量, 是变量就要占用内存, 在32bit系统中, 占4字节. 在64bit系统中, 占8字节.
- 由指针变量获取其指向的值的操作叫**解引用**.
- 无论指针是什么类型, 它存放的都是一个地址, 只不过这个地址上存放不同类型的数据而已.
- 既然一个指针变量所占内存的大小不会改变, 为什么还要给指着指定一个类型呢? 为一个指针指定类型主要是为了应对编译器的类型检查, 编译器在编译过程中, 会根据指针指向的数据类型对程序进行语义检查, 看程序有没有错误. 另外一个重要原因是不同类型的指针, 运算规则不一样, 更适合我们通过指针去访问不同类型的数据.
- 指针一般可以分为3大类:
  - 函数指针: `void (*pfunc)(int, int)`
  - 对象指针: `char*, int*, struct xx*`
  - void*指针: 一般作为通用指针, 作为函数参数
- 

### 指针与const

记忆秘诀: const就是“常量”, * 就是“指针”, 读的时候就按符号的顺序读.

#### 常量指针(最常用)

- 不能通过解引用的方法修改内存地址中的值, 但是用原始的变量名是可以修改的.
- 格式: `const int* a;`
- 这种指针就是只读的指针, 解引用的话只能读. 但是你还可以让它重新指向别的变量.
- 也就是说它解引用之后不能作为左值.
- 使用场景: 一般用于修饰函数的形参, 表示不希望在函数里面修改内存地址中的值.
- <u>就是它指向的东西是个常量.</u>
- 常量指针, 指向常量的指针, 所以它指向的东西是个常量.

#### 指针常量(少用)

- 格式: `int* const a;`
- <u>这个指针是一个常量, 只是指针的指向不能改变. 也就是这样的指针自始至终都只能指向初始化时的那个变量</u>
- 在定义的时候必须初始化, 否则没有意义.
- 可以通过解引用的方法修改内存中的值.
- 指针常量, 这个指针是个常量, 指针的值不能变, 也就是这个变量里存的那个地址不能变, 也就是指针的指向不能变.

#### 常指针常量(基本不用)

- 指向不可改变, 也不能通过解引用修改指向的变量的值.
- 格式: `const int * const a;`
- 就是兼具上面两个的功能.

---------------------------------------------

### 指针与数组

- 其实对数组的操作就是使用指针对内存操作的一种封装. 你用下标运算符[]进行操作的时候, 其实这只是看起来的, 编译器实际做的时候, 就把这个写法解释成了指针的写法, 有数组那一套操作只是方便了程序员写代码而已.
- 当数组作为函数的参数的时候, **它实际传入的就纯粹只是一个首地址信息**, 其它任何信息都不携带! 把首地址给到函数, 函数想怎么玩这个首地址后面的内存, 那就怎么玩, 想玩多少就玩多少, 哪怕越界它也不会管! 所以一般数组作为函数参数的时候, 都会把数组的大小也传给函数.

#### 指针数组

- 这个很好理解, 不就是数组中的元素全都是指针么.
- 格式: `int* arr[10];`这就定义了一个指针数组.

#### 数组指针

- 顾名思义, 就是指向数组的指针. 其实这个也叫行指针, 一般只用在二维数组里面.
- 格式: `int (*parr)[10];`感觉跟函数指针有点类似. 它们加小括号其实是因为运算符优先级的问题.
- 在C中, 一维数组的数组名是第一个元素的地址, 而对数组名取地址, 得到的是个**行地址**. 二者在数值上是相等的, 但是意义并不相同, 你可以试验一下, 对这两个指针进行偏移, 它们的**偏移量**是不同的.
- **二维数组名是一个行地址.**
- 比如`int arr[m][n];`的意思是: 定义一个数组, 里面有m个元素, 每个元素都是一个长度为n的整型数组.
- **其实这跟一维数组是一致的!** 它的这种`arr[1][2]`的写法也只是一种表象而已, 只是一种记号, 编译器同样会把它展开, 然后使用指针去搞. 你看`arr[1][2]`其实展开就是`*(*(arr+1))+2)`, 因为`arr`是行指针, 所以`arr+1`就是先偏移到指定行, 然后`*(arr+1)`就是对这个**行指针解引用**, 那解完就是数组(因为你数组取地址就是行指针啊)了, 然后`(*(arr+1))[2]`不就可以拿到数据了, 再展开一层就是`*(*(arr+1))+2)`了.
- 二维数组作为函数参数有两种书写方式:
  1. 二维数组的写法: `int func(int arr[][3], int length);`
  2. 数组指针的写法: `int func(int (*arr)[3], int length);`
- 

--------------------------------------

### 二级指针

主要用来传递地址, 就是为了在函数中修改指针变量的指向, 而不是修改指针变量指向的值.

一级指针在函数中只能修改它指向的变量的值, 而指针变量的指向是变不了的. 这里说的变不了说的是回传不回去.

--------------------

### 空指针

- 就是NULL, 它通常的定义是`#define NULL 0`或`#define NULL (void*)0`.
- 直接对空指针解引用会导致程序崩溃.

---------------------

### 野指针

- 就是指向的地址不是有效合法地址的指针.
- 在程序中访问野指针, 可能会造成程序的崩溃.
- 产生野指针的场合:
  1. 定义指针变量的时候, 没有初始化.
  2. 本来指向的是动态分配的内存, 但内存被释放之后, 指针没有置空, 但是指向的地址已经失效.
  3. 当前上下文已经超越指针所指向的变量的作用域.
- 野指针的危害要比空指针大很多! 因为如果在程序中访问空指针, 会直接导致程序崩溃. 但是如果访问的是野指针, 并不一定会导致程序崩溃, 而只是表现出程序运行不稳定, 这就增加了程序调试的困难程度.

--------------

### 函数指针

- 就是指向函数的指针.


----------------

### 指针函数

- 其实搞出来这个名字感觉是有点牵强的, 只不过是一个函数的返回值是一个地址而已.

-------------------



## void

- void在C中表示无类型, 主要有3种用途:
  1. 如果函数的返回值为void, 表示函数无返回值.
  2. 如果函数的参数为void, 表示函数不需要参数.
  3. 如果函数的参数为void*, 表示接受任意类型的指针.(最重要)
- 下面主要讲的就是void* :
- 不能用void声明变量, 它不能代表一个真实的变量.
- 不能对void*指针直接解引用, 需要先转化成其它类型的指针.
- 把其它类型的指针赋值给void*指针, 不需要显式类型转换.
- 把void*指针赋值给其它类型的指针, 需要显式指定类型.
- <u>总之也就是说, 在把void*指针作为右值之前, 需要先提前说明一下要把它转化成什么类型的指针.</u>
- void* 最常用的地方就是作为函数的形参.

--------------------------------





## Makefile

- make是一个工程构建工具, 它可以根据Makeflie指定的规则来自己自动的调用gcc来编译构建整个工程.

- 不同厂商的make各不相同, 也有不同的语法, 但其本质都是在“文件依赖性”上做文章. 其中应用最为广泛的还数**GNU的make**.

- make命令执行时, 需要一个Makefile文件, 以告诉make命令需要怎么样去编译和链接程序.

- 会不会写Makefile, 从侧面说明了一个人是否具备完成大型工程的能力. 因为Makefile关系到**整个工程的构建规则**. 一个工程中的源文件不计其数, 其按类型, 功能, 模块又分别放在若干目录中, Makefile定义了一系列的规则来指定哪些文件需要先编译, 哪些文件需要后编译, 哪些文件需要重新编译, 甚至于进行更复杂的功能操作, 因为Makefile就像一个shell脚本一样, 其中也可以执行操作系统的命令. Makefile带来的好处就是“**自动化编译**”, 一旦写好, 只需要一个make命令, 整个工程完全自动编译, 极大的提高了软件开发的效率. make是一个命令工具, 是一个解释Makefile中指令的命令工具. 一般来说, 大多数的IDE都有这个命令.

- Makefile的**基本规则**:

  1. 如果这个工程没有被编译过, 那么所有的.c文件都需要被编译和链接.
  2. 如果这个工程的某几个.c文件被修改, 那么我们只需要编译被修改的.c文件, 再进行链接.
  3. 如果这个工程的一些头文件被修改了, 那么我们需要重新编译引用了这几个头文件的.c文件, 并进行链接.

- 只要我们的Makefile写得够好, 所有的这一些, 我们只用一个make命令就可以完成, make命令会自动智能地根据当前文件修改的情况来确定哪些文件需要重新编译, 从而自己去编译所需要的文件并进行链接.

- 以前直接使用`gcc a.c b.c d.c -o main`这样命令的编译, 有一个问题就是, 如果是多文件工程, 那我一旦修改了`a.c b.c d.c`其中的一个, 那我再执行这条命令的时候, 那这些所有的`.c`文件都又会被再编译一遍, 而这根本没必要. <u>所以啊, 我们应该把每个.c文件的预处理, 编译, 汇编这3个过程给独立起来, 这样我们把每一个.c都编译成一个.o分立在那, 如果其中有一个.c文件改变了的话, 我其它的.o就不用动, 我只需要把改动的那个.c对应的.o给编译一下就可以了, 然后最后再执行一步链接的命令就可以了.</u> 所以总结一下也就是说: <u>每次重新构建工程我的工作就是: 重新生成一下新改动的.c的.o, 然后再整体构建一下即可.</u> 对啊, 其实Makefile就是干的这活儿!!!

- **那问题就来了**, Makefile怎么知道目前的.o是不是最新的呢? 也就是它怎么知道每个.o对应的.c是不是需要再重新生成一下的呢? 其实就是每次构建前, 它就比较一下当前.c的时间戳和当前已有的它对应.o的时间戳, 如果.c的时间戳更靠后一点的话, 那就说明现在这个.o已经过时了, 也就是.c有改动, 所以它就会自动再编译一下那个.c

- ```bash
  # Makefile的基本语法
  目标:一个或多个依赖
  	由依赖获得目标所需要执行的命令
  ```

- **当依赖文件比目标文件更新时, 就执行命令, 重新生成目标文件.**

- 怎么使用Makefile? 就是在Makefile所在的文件夹下执行make命令, make命令后可以跟你想生成的目标, 如果不跟的话默认生成第一个目标.

- 

--------------------------------



## CMake

- CMake是一个**跨平台**的编译工具, 可以用**简单的语句**来描述**所有平台**的编译过程. 只需要一个CMakeLists.txt指定一下构建规则和一些必要的信息, 它就能够**自动生成**各种各样的Makefile文件, 然后就可以使用make命令完成整个工程的构建..

- 首先手动编写一个CMakeLists.txt, 然后执行cmake PATH生成Makefile, 最后执行命令make进行编译.

- CMake中支持大写, 小写, 混合大小写的**命令**. 但一般都约定俗成使用大写命令. 命令的参数用括号括起来, 参数之间使用空格隔开, 参数是大小写敏感的.

- 一般都是项目的顶层文件夹里放一个CMakeLists.txt文件.

- 在终端中使用cmake --version来查看安装的cmake的版本.

- ![image-20220730170546668](C:\Users\屠文博\AppData\Roaming\Typora\typora-user-images\image-20220730170546668.png)

- ![image-20220730173128939](C:\Users\屠文博\AppData\Roaming\Typora\typora-user-images\image-20220730173128939.png)

- ![image-20220730181538323](C:\Users\屠文博\AppData\Roaming\Typora\typora-user-images\image-20220730181538323.png)

- ![image-20220730181817785](C:\Users\屠文博\AppData\Roaming\Typora\typora-user-images\image-20220730181817785.png)

- ![image-20220730182102315](C:\Users\屠文博\AppData\Roaming\Typora\typora-user-images\image-20220730182102315.png)

- **注意!!!!: target_link_libraries命令要放在add_executable命令之  后  才行.**

- ![image-20220730182321737](C:\Users\屠文博\AppData\Roaming\Typora\typora-user-images\image-20220730182321737.png)

- ![image-20220730182611176](C:\Users\屠文博\AppData\Roaming\Typora\typora-user-images\image-20220730182611176.png)

- ![image-20220730182711063](C:\Users\屠文博\AppData\Roaming\Typora\typora-user-images\image-20220730182711063.png)

- ```bash
  //! 使用CMake的简单示例操作步骤:
  //! 1.新建一个demo文件夹, 进入demo, 新建inc文件夹, src文件夹, build文件夹, main.cpp文件, CMakeLists.txt文件
  //! 2.在inc文件夹里面写头文件, 在src文件夹里面写源文件. 在main.cpp里面调用它.
  //! 3.编写CMakeLists.txt, vim打开它, 里面写上下面的:
  #----------------------------------------------------------------------------------------------
  #指定要求的CMake最低版本, 可以先通过 cmake --version 命令查看一下自己装的cmake的版本.
  CMAKE_MINIMUM_REQUIRED(VERSION 3.10)
  #指定工程名.
  PROJECT(MAIN)
  #指定头文件搜索路径, 其实这里括号里的参数就是gcc中的 -I 选项.
  INCLUDE_DIRECTORIES(inc)
  #生成目标文件, 要指定生成目标文件所需要的源文件. 比如生成目标文件main, 需要main.cpp和src目录下的xxx.cpp
  ADD_EXECUTABLE(main main.cpp ./src/xxx.cpp)
  #-----------------------------------------------------------------------------------------------
  ```

- 

-----------------

- 全局变量加个g前缀, 静态变量加个s前缀, 成员加个m前缀, 指针变量加个p前缀, 函数指针变量加个fp前缀.
- **栈可以分为4种类型: 满增栈, 满减栈, 空增栈, 空减栈.**
- 满栈full stack: 说的是SP始终指向的最后入栈的那个元素. 入栈是先调整SP再压数据. 出栈是先弹数据再调整SP.
- 空栈empty stack: 说的是SP时钟指向下一个将要放入数据的位置. 入栈是先压数据, 再调SP. 出栈是先调SP, 再弹数据.
- 增, 减: 说的是栈的生长方向. 增是向上生长, 减是向下生长.
- 在内存里面最常用的就是**满减栈**. 为什么? 首先解释为什么用“满”: 因为你都不知道下一次要压入的局部变量是什么类型, 你为啥要指向下一个位置呢? 你指的也不一定对啊, 所以还是不要指了; 再解释为什么用“减”: 因为低地址一般都被操作系统啊, 代码啊, 数据啊, 被这些东西给占了, 而你的栈又是一个伸缩的东西, 所以栈底最好是不要变的, 那就把栈底安排到高地址吧, 增长的时候往下增长, 这样栈的可增长空间就很大了, 所以也就使向下生长了!
- 
- 全局变量的初始化跟局部变量的初始化还是不一样的. 局部变量由于它只在它的作用域里面有用, 也就是在栈里, 所以要使用它的时候, 直接使用指令, 把初始值直接含到指令里就可以初始化那个变量, 在栈里就建立好它了; 而全局变量是始终有效的, 所以在进入main函数之前就要初始化好, 那怎么初始化呢? 其实就是直接把初始值存到flash里的.data段, 然后上电之后先把所有全局变量的初始值复制到内存中, 每个位置也就对应一个全局变量, 这样就不必使用指令来挨个初始化全局变量了, 比较方便, 也节省flash空间. (其实把全局变量的初始值复制到内存中的哪个地址也是可以你自己手动指定的)
- 诶那既然是这样, 那这就又引出一个问题了啊: 那我没有初始化的全局变量, 也就是初始化的值都是0的全局变量, 那我怎么给它初值呢? 我还需要在flash中把所有的0都记录下来, 然后复制过去吗? 显然没必要这么干! 这也就有了.bss段.
- 也就是说有初始值的全局变量, 它们的值会被从flash中复制到内存中; 而没有初始值的全局变量, 只需要一个SET指令, 把那一段内存设置为0就可以了.
- 堆其实也没什么神秘的, 它就是一块空闲内存而已, 只不过这块空闲内存被算法给管理了起来! 我要使用这些内存我就调用内存管理算法提供的接口! (堆和栈那种相对关系, 是一种典型的结构)
- 堆的本质就是一块被管理的空闲内存! 那我定义一个数组, 并给它配一套管理数组的算法, 那我这个数组算不算堆呢? 当然算了! 
- 

---------------------------

- 目标文件可分为3种:
  1. 可重定位目标文件: 被用于静态链接的文件, 都是可重定位目标文件. 因为静态链接时, 逻辑地址要被重定位为运行地址, 所以就称为可重定位目标文件.
  2. 可执行目标文件: 可以被执行的文件就是可执行目标文件, 其实就是常说的可执行程序.
  3. 共享目标文件: 被动态链接的文件就是共享目标文件. 其实就是动态库, 它也叫共享库.
- 不同操作系统的目标文件格式是不同的. 格式规定了目标文件中指令和数据的组成结构, 每个操作系统只认自己的格式. 虽然不同格式之间有区别, 但是大致都是类似的.
  - 裸机目标文件, 一般都是.bin格式的.
  - 现代Unix系统下目标文件一般是ELF格式的, 即Excutable and Linkable Format.
- 

### ELF

#### 可重定位目标文件的ELF格式

- ELF格式一共分为12个节, 每个节都有一个编号, 从0开始编, 编号的作用就是用来索引不同节的.
- 编译出来的每一个.o都是这样的结构. 链接时要做的就是将ELF格式的.o全部合成(合并同名的节, 并添加和删除某些节)为一个完成的ELF格式可执行文件.
- 每个节都是从0开始编号的, 这个地址是逻辑地址.
- 下面是可重定位目标文件的结构: (从低地址开始, 也就是下面编号越低表示实际地址越低)
  1. ELF头: 存放ELF格式所需要的一些基本信息. 比如: 机器字长, 大小端等等. 可以使用readelf -h 目标文件命令查看可重定位目标文件的ELF头的信息. (readelf命令用来读取目标文件的ELF格式信息, 不同的选项表示查看不同的节. -h是查看ELF头, -s是查看.symtab符号表)
  2. .text节: 是一个只读节, 存放所有函数的机器指令, 不过某些常量也会直接和指令一起存放到.text节中.
  3. .rodata节: 只读数据节, 存放一些常量数据. 比如: const修饰的, 字符串常量, 格式化字符串也是.
  4. .data节: 存放已经初始化了的全局变量和static修饰的变量. (其实我感觉全局变量和局部变量就是两个完全不一样的东西, 它们的存储位置, 初始化方式完全不同. 因为你局部变量是存放在栈中的, 而栈的操作方式只有PUSH和POP这两条指令, 所以其实你的局部变量也就是一个PUSH而已, 另外我觉得读写局部变量应该就是靠SP和一个偏移来实现的)
  5. .bss节: 存放未初始化的全局变量和静态变量, 由于没有初始化数据, 所以在可重定位目标文件中, 这个节实际并不占空间, 它只是一个占位符, 只有程序加载进内存了, 才会在内存上真正开辟.bss空间, 并在.bss空间中开辟对应变量的空间, 并自动初始化为0.
  6. .symtab节: 即符号表, 每一个.o文件都有一个符号表, 用于存放.o中所定义和引用的全局符号的信息(也就是全局变量和符号信息). (其实想想, 好像也确实没有什么符号需要记录啊). 在符号表中只记录了符号的基本信息, 如符号是否定义, 符号对应的空间再哪个节中等, 符号的名字本身并不存储在符号表中, 而只是存储了名字对应的一个索引. (这也很自然嘛, 处理符号对应的索引, 总比直接处理符号来的方便啊) (众多的.o之所以能被正确的链接到一起, 符号表功不可没. 链接的时候必须查看各自.o中的符号表, 才能将各自符号表的定义和引用关联起来)
  7. .rel.text节: 将多个.o链接到一起时, 会将同名的段给整合到一起, 在整合的时候必须依赖.rel.text中所记录的一些有关.text的信息.
  8. .rel.data节: 这个节的作用跟.rel.text类似, 是整合.data段时需要依赖的信息.
  9. .debug节: 调试符号表, 记录调试信息, 编译时加上-g选项才会在.debug中加入调试信息.
  10. .line节: 存放代码的行号, 因为调试的时候往往需要显示源代码的行号. 只有加入了-g选项才会添加行号信息.
  11. .strtab节: 即字符串表, 存放一些字符串, 比如.stmtab和.debug中所用到的符号命, 每个节的节名, 源文件名等.
  12. 节头部表: 描述目标文件的每个节的相关信息, 不必了解.
- 
- 

##### 符号表.symtab

- 可以把符号表就理解为是对.strtab中各个字符串的详细信息描述!
- 符号表中记录的符号是从.s文件中来的. 
- 符号表中的符号就两种:
  1. 全局符号: 就是某个模块定义后, 还能被其它模块引用的符号. (符号表中的全局符号有可能是这个模块定义的, 也有可能是它引用的别的模块的) (全局符号, 首先它叫“全局”, 意思就是它天生就是可以被其它模块引用的, 只是奈何编译是独立进行的)
  2. 本地符号: 就是本模块定义的, 而且只在本模块中有效的符号, 也就是static修饰的符号. (注意: 如果定义的一个变量或函数, 我只希望它在本模块内使用, 就应该加上static修饰, 把它退化成本地符号, 否则它就是泄露在全局的, 而这个泄露是不应该的! 如果泄露的话, 可能会导致一些错误, 比如命名冲突等)
- 符号表是怎么记录符号信息的? 符号表中有很多条目, 每个条目记录的就是一个符号的基本信息, 其实这一个条目在实现上就是一个结构体而已, 其中有一个成员是符号在.strtab中的索引, 其它成员就是描述这个符号的信息的:
  1. int name: 这不是一个字符串, 符号名字字符串都放到了.strtab中, 这个name只是它的名字字符串在.strtab中的偏移, 也就是一个索引.
  2. int value: 存放的是地址, 也就是这个符号对应的空间的首地址. 如果是变量, 那就是.data中变量的起始地址; 如果是函数, 就是.text中函数代码的起始地址. (注意: 对于可重定位目标文件和可执行文件中的value是不同的. 在可重定位目标文件中, value存放的只是相对所在节起始地址的偏移. 而可执行文件中value存放的是绝对地址(这个我不是很理解)) (每个节都是从0开始编号的, 所以.text段中的每个函数都会有一个相对地址, .data中的每个变量也都会有一个相对地址)
  3. int size: 前面的value只是表示了个起始地址, 并不能表示指向的空间的大小, 所以这个size成员就是用来指明大小的. 如果是变量, 那就是变量在.data所占的字节数. 如果是函数, 那就是函数的代码在.text中占的字节数.
  4. char type: 表示符号类型. 如果是FUNC, 表示符号代表的是函数; 如果是OBJECT, 表示符号是全局变量; 如果是FILE, 表示符号是源文件的名字. (标准中的`__FILE__`宏是不是就是借助这个实现的啊)
  5. char bind: 就两种, 如果是LOCAL, 表示符号是本地符号; 如果是GLOBAL, 表示符号是全局符号.
  6. char section: 有4种取值: 节索引号(这个符号在哪个节中), ABS(表示该符号不需要被链接器处理), UNDEF(表示该符号只是在本模块中引用, 在这个模块中找不到它的定义, 在链接的时候要去其它模块中寻找它的定义), COM(表示该符号是未被初始化的全局变量)
- 

#### 可执行目标文件的ELF格式

- 怎么得到可执行目标文件? 使用链接程序collect2/ld, 将所有可重定位目标文件静态链接在一起, 就得到了可执行目标文件.
- 链接动态库时, 只是留下了函数的接口, 当程序运行时才把需要的动态库加载到内存中.
- 静态链接时, 静态链接器主要做2件事:
  1. 符号解析: 确保模块中引用的每个符号都有明确的定义, 并将每个符号的引用和定义关联起来.
     - 就是对于本模块中标记为UNDEF的符号, 静态链接器去别的模块的.symtab中查找, 看看是否有定义, 有了就建立关联, 没有就报错. 
     - 同一个模块中的全局符号重复定义在编译期就能检查出来, 而不用模块之间的全局符号重复定义, 只有在链接的时候才能检查出来.
     - 链接器是如何解决不同模块之间全局符号重名(不同模块间的本地符号重名没问题, 所以下面就不考虑它)的问题的? 首先, 全局符号重名这个问题是不可避免的! 因为进行模块化编程的时候, 一个模块想引用另一个模块中的全局符号, 就必须在本模块中声明它, 而这个声明就引起了重名, 因为这个符号也是放在符号表里的.
     - 答: 链接器是通过 重名符号的强弱共存规则 来解析的.
     - 全局符号有强弱之分:
       - 对于全局变量: 强符号是指初始化了的全局变量, 弱符号是指未初始化的全局变量.
       - 对于函数: 强符号是指函数定义, 弱符号是指函数声明.
     - 每个符号是强符号还是弱符号, 在.symtab中都有记录.
     - 重名符号的强弱共存规则:
       1. 不允许多个重名强符号同时存在, 否则报错.
       2. 只有一个强符号, 其它重名符号都是弱符号的话, 进行整合时, 保留强符号, 舍弃弱符号.
       3. 所有重名符号都是弱符号的话, 则只保留其中某个, 其它全部舍弃, 保留谁由链接器来决定.
     - (其实在同一个模块中, 编译器编译的时候也是按重名符号的强弱规则来进行的取舍的)
     - 注意!!! 事实上, 对于编译器, 链接器来说, 它们并不知道什么是声明, 什么是定义, 声明和定义只是学习C语言时为了方便表述, 我们自己给的. 编译器, 链接器只知道强符号, 弱符号, 解析时就是按照重名符号的强弱共存规则来的. 之前说的: 函数在后面定义, 在前面声明. 其实啊对于一个全局变量你也可以在定义在后面, 在前面声明一下啊! 但是这样做很没有意义啊, 而且还影响可读性, 所以就从来没有这么干过, 其实这是完全可行的, 因为二者都是全局符号啊, 处理都是类似的, 也就是说, 可以利用弱符号(声明/不初始化)把强符号(定义/初始化)的作用域给提前! 
     - 其实声明和定义这两个概念本身的定义就不是很严格, 有时候就分不出来哪个是定义, 哪个是声明, 所以以后也不必非要严格区分它们!
     - 
  2. 地址重定位: 
